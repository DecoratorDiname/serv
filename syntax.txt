Модуль 3
Разработка серверной части

3.1 работа с базой данный

База данных - набор информации которая хранится упорядочено в эллектронном виде
Реляционные бд - данные представленные в виде таблиц(exel)
В терминологии таблицы называются сущьностями
Основные БД выраженны в популярных приложениях: postgreSQL, mySQL, SQL server.
Сервер БД УСТАНОВИТЬ ДОМА
Для работы сервера postgreSQL используется зачастую отдельное клиентское приложение
скачать бобра
Каждое значение первой строки каждой строки называется атрибутом
Значение атрибутов читаются построчно
Первая колонка в каждой таблица должна являтся первичным ключом
Первичный ключ это уникальное значение которое присвоено каждой строке
Первичный ключ должен быть:
1)Целое число
2)Не отрицательное и не 0
3)Должен являтся авто заполняемым
Внешний ключ - это ссылка из смежной таблицы на первичный ключ в таблице с которй она связана

Определение нормальных форм
Для того чтобы будущая БД работала её необходимо нормализовать.
1 нормальная форма - это когда все атрибуты и их значения атомарны(неделимы)
2 нф - это когда в каждой таблице имеется колонка с id
3 нф - для связи используется смежная таблица с внешними ключами
Значение 1 строк таблицы ноходятся критерии сущьностей
SQL запросы делят на следующие основные типы:
1)DDL - операторы опредиления данных(CREATE,DROP)
2)DNL - операторы манипуляции данных, которые работают с содержимым таблицы (UPDATE,SELECT,DELETE,INSERT)
3)DCL - операторы определения доступа данным для разных пользователей(GRANT,DENY)
4)TCL - язык управления транзакциями, тоесть сериями команд которые выполняются поочерёдно.Если хотяби 1 из команд не выполнена, все последующие тоже отменяются.Пример: команда BEGIN TRANSACTION обозначается начало транзакции, COMMIT TRANSACTION это изменение команд в цепочке, SAVE TRANSACTION это промежуточная точка сохранения на пути транзакции
Типы данных
1)Наиболее подходящий тип данных для первичных ключей это SERIAL и NOT NULL
2)Если кол-во символов примерно известно зарание и оно состовляет не больше 255, то правильно использовать varchar(если нужно ограничить до 10 символов, то нужно написать varchar(10))
3)текстовый - это когда не известно кол-во символов, ставится динамическая величина ставится text
4)numeric - для чисел с плавающей запятой
5) для целочисленных значений без автозаполнения используется тип данных - integer
Внешний ключ должен описыватся с типом данных integer
6) типы данных для дат используется timestamp
ограниченик check: alter table orders add check (status in('открыт', 'закрыт'))
запрос вывода всех клиентов с их данными: select * from clients
запрос с условием: select * from orders where status = 'закрыт'
вывевсти все топары дороже: select * from products where price > 90
условие с фильтрацией: select * from clients where rating > 3 order by rating, asc сортирует значение по возрастанию, а desc в порядке убывания
Вывести общее количество клиентов 
select count() as total_clients from clients
Вести среднее количество 
select avg(price) as avg_price from products
Вывести самый дорогой и самый дешёвый товар
select max(price) as max_price, min(price) as min_price from products
Количество заказов по статуса
select status,count(*) as orders_count from orders group by status
Вывести все заказы с информацией об клиентах и заказов (имя клиента, название продукта, цена продукта, количество продукта и тд)
select 
o.order_id,
c.name as client_name,
p name as product_name,
p.price as product_price,
o.status,
o date
from orders o
join clients c on o.client_id = c.client_id
join products p on o.product_id = p.product_id
Вывести средний чек по клиентам 
select 
c.name as client_name,
avg(p.price) as avg_order from orders o
join clients c on o.client_id = c.client_id
join products p on o.product_id = p.product_id
group by c.name
order by avg_order asc 
Вывести id и ФИО клиентов которые не делали заказов 
select 
c.name,
c.client_id
from clients c
left join orders o on o.client_id = c.client_id
where o.order_id is null
left join это операция внешнего левого соединения, которые возвращает все записи из левой 1 таблицы и только те совпадающей 2 таблице которые соответствуют условию соединения (через оператор on)


create or replace function update_order_item_price() 
returns trigger as $$  
begin new.price:=(
select price from products where product_id = new.product_id
) * new.count;
return new;
end;
$$ language plpgsql;


create trigger trg_calculate_order_item_price
before insert or update on order_items 
for each row execute function update_order_item_price();


Модуль 4 клиент серверная разработка

сервер - физическая или виртуальная высокопроизводительное устройство, которое должно иметь доступ к интернету
сервер это отдельно запушенное приложение(Node.JS)

Node.JS этол платворма для javascript построенная как v8 которая позваляет запускать js код вне браузера, на сервере и на любом компьютере

Ключевые особености при работе с Node.JS:
1)Асинхронность и событийно-ориентированная архитектура
1.Неблокирующий ввод/вывод
Когда серверу нужно выпольнить операцию ввода\вывода (например. прочитатьт файл диска, сделать запросы с бд) оно не ждёт его завершения, вместо этого приложение продолжает выполнять другой код. Как только операция завершается вызывается специальная функция обработчик (
callback)
2.Однопоточность с циклом событий(eventloop)
В основе js лежит однопоточная модель. Однако это не значит что он может делать только 1 вещь за раз.Цикл собыйтий - это механизм который постоянно проверяют, завершились ли какие либо ассинхронные операции. Если операция завершена, он ставит её callback в очередь на выполнение.
2)NPM(Node package manager) node.js поставляется со своим менежером пакетов npm.Это огромная экосистема открытых библиотек и инструментов, которые очень лекго установить и использовать в своих проектах.
Какие работы выполняются на сервер Node.js при разработке клиент серверных приложений
1 этап: Создание HTTP сервера: 
подключаем модуль express.js
создание экземпляра приложение и опредиление порта, на котором сервер будет принимать входящие и исходящие подключения
2 этап: Подключение к бд
Использует важный модуль pg
настройка подключения к СУБД с использованием соответствующего драйвера или ORM/ODM системы
Создание конфигурационного файла бд(в нём мсы указываем пораметр подключения к бд) 
3 этап: разработка промежуточных обработчиков(middlewhere)
Разрабатываются функции и компоненты обрабатывающие входящие http запросы, до того как они достигнут маршрута
4 этап: Опредиление модели данных
Разработка модуля которая описывает структуру данных которая будет хранится в бд(таблицы,коллекции,поля,типы данных, связи)
Это делается либо с помощью sql скриптов или через ODM модули
5 этап: создание маршрутов routes и api-endpoints
Разработка обрабодчиков для различных http запросов по определённым url адрессам (endpoint-там). Каждый маршрут соответствует конкретной операции
6 этап: Реалицазия контролерров(controllers)
Написание функций - разработчиков которые привязаны к маршрутам. Эти функции содержат бизнес логику: получают данные из запроса, взаимодействубт с бд(через модели) и отправляют ответ клиенту
Хорошим тоном является разработка дополнительных модулей отвечающих за обработку ошибок и валидации данных,настройка пременных окружения
Http методы определяют действия которое клиент хочет выполнить с ресурсом на сервере, они являются основной семантикой restful API
1)Метод get это безопасный метод получения информации в бд (пример get/api/clients) выводит список всех клиентов
get/api/clients/1 вывод клиентом с 1
2)Метод post(создать-отправить) небезопасный(менят состояние сервера), неидемпотентный(2 одинаковых запроса создадут 2 ресурса).Данные запроса передаются в теле запроса body(пример post/api/clients)
3)Метод put(обновить/заменить) полное обновление или замена существующего ресурса небезопасный, идемпотентный запрос
4)Метод patch(частично обновить) применяется чтобы изменить какие-то данные у пользователя
5)Метод delete(удаление) удаление ресурса небезопасный, иденпотентный

Коды ответов сервера.
Это трёхзначные числа, которые лежат от 100 до 503, которые сервер отправляет на http запрос. Они отправляь клиенту результат выполнения операции и групируются по 1 цифре
1xx- это информационные. 100 - сервер готов принять тело запроса
2хх- это сообщение об успехе. 
3хх- перенаправление. необходимо сделать дополнительное действие.(например. перейти по другому адресу)
4хх- ошибки клиентиа. сервер не может обработать запрос из за некоректного синтаксиса. 401 для незаригестрированых пользователей. 403- блок. 404 не может найти запрашиваемвчый ресурс. 429 слишком много запросов за короткое время
5хх- ошибки сервера. сервер не смог выполнить запрос по своей вине. 500 обшая ошибка сервера из-за бага в коде. 502- плохое соединение.503 сервер перегружен или тех.обслуживание

РАБОТА С ДАННЫМИ В ТАБЛИЦЕ
таблица создаются тегом  table
таблица состоит из 3 основых частей
thead - заголовку колонок
tbody - основная часть всех данных, все значения
tfoot - итоговые результаты, подчёты

tr - создание 1 строки
для каждой строки td-ячейки,th-заголовки

Необходимо написать функцию для отрисовки таблицы(добавление строк и ячеек и вписать в каждую ячейку соответсвующие даные из масива обьектов dataSet)

const thead = document.getElementById('.myTable_thead');
const tr = thead.insertRow(); insertRow позволяет добавлять строку внутри родительского элемента
const td = tr.insertCell(); insertCell добавляет ячейку


минусы кода через innerHTML
данный код будет работать, он является хорошим примером, но только в том случаи если структура масива с данными не будет менятся(не будут менятся новые атрибуты)
потенциальная уязвимость при использовании внешних данных, если вдруг в данных окажется строка с HTML тегами, то при вставки через innerHTML этот код выполнится, это называется XSS-уязвимость
не рекамендуется отрисовывать метод HTML 
вариант 2
более безопасный и контролируемый способ(создание элементов через create element,appendchild, и запись данных через textcontent)
этот вариант решает проблемы через XSS и даёт больше контроля над каждым элементом
основная суть подхода зашить каждую ячейку в каждую переменную и присвоить её значение из масива через textcontent, так как он безопасный, но есть нюанс, ограничены количеством атрибутом и данных которые можно внести

const createElement =(dataSet) =>{
    const tbody = document.getElementById('myTable_tbody');

    dataSet.forEach(element => {
        const row = document.createElement('tr');

        const cellId = document.createElement('td');
        cellId.textContent= element.id;
        row.appendChild(cellId);  

        const cellName = document.createElement('td');
        cellName.textContent = element.name;
        row.appendChild(cellName);

        const cellAge = document.createElement('td');
        cellAge.textContent= element.age;
        row.appendChild(cellAge);

    
    tbody.appendChild(row);
});
}
createElement(dataSet);




const tableParser = (dataSet) =>{
    const thead = document.getElementById('my_thead');
    const headerRow = thead.insertRow();
    const headers = Object.keys(dataSet[0]); 
    headers.forEach(headerKey => {
        const cell = headerRow.insertCell();
        cell.textContent = headerKey;
    });


    const tbody = document.getElementById('my_tbody');
    dataSet.forEach(Element => {
    const bodyRows = tbody.insertRow();
    headers.forEach(headerKey => {
        const cell = bodyRows.insertCell();
        cell.textContent = Element[headerKey];
    });
    });

}; 
tableParser(dataSet);

в js файле добавить 2-ю функцию, которая будет брать строковые данные из input поля(в html разметке)при нажатии на кнопку и применять фильтр к данным для заполнения таблицы
input.value
filter()
includes()
string(value)
добавить кнопку удаления фильтра



express-создание сервера
pg-подключение бд
cors-подключение других серверов
nodemon-упрощает работу с запуском сервера
sequelize-ORM система которая позворляет создавать модели данных, которые на языке js позволяют описать сущьности базы данных




async function func(){
    try {
        const result = await
        alert("5");
        
    }
    catch(error){}
}


функция asyng делает 2 важные вещи:
1. возвращает промисы
2. позваляет использовать await внутри функции

await заставляет js ждать, пока promise не будет выполнен или отклонён


const Client = sequelize.define(
    'clients',
    {
        id:
        {
            type: DataTypes.INTEGER,
            allowNull: false,
            primaryKey: true,
            autoIncrement: true
        },
после того как мы описали модели данных(Client, Product,Order,Oreder_Item) мы должны экспортировать их и импортировать их в index.js через import, помимо этого необходимо добавить promiseв блоке 
try для создание/перезаписи таблиц бд. Делаесть при помощи функции await sequelize.sync().

Связи
 
Client.hasMany(Order)
Order.belongsTo(Client)

Order.hasMany(Order_Item)
Order_Item.belongsTo(Order)

Product.hasMany(Order_Item)
Order_Item.belongsTo(Product)


___________________________________________


app.use(cors())
app.use(express.json())
app.get('/',(req,res)=>
    {
        res.status(200).json(
            {
                message: 'work!'
            })
    })

use это метод настройки промежуточного ПО используемого маршрутами обьекта сервера express
express.json это встроеная функция разбирающая входящи запросы в обьект формата json, 
функция get принимает в себя 2 параметра
1. http метод (get,post,put,delete,patch и тд)
2. футь на сервере(/)
3. доп. hangler function выполняется при совподении маршрута

req - request это обьект запроса, тоесть то что прислал клиент, из него читают данные
res - response это обьект ответа, данные в ответ клиента
get запрос работает но его необходимо заполнить более правильным способом- сделать метод асинхронным, обезопасить код, добавить обработку ошибок, сделать маршрут более конкректным 	


app.get('/api/getClients', async(req,res)=>
{
    try 
    {
        const getClients = await Client.findAll()
        res.status(200).json(getClients)
    }
    catch(error)
    {
        res.status(500).json({
            message: 'Ошибка при получении данных'
        })
    }
})

http методы по разным моделям данных необходимо разнести по разным модулям
создаём папку routes в которой созадаём роутеры для каждой модели данных, добавляем файл route.js который будет главным маршрутизатором. 
он будет вызывать нужные функции со своими маршрутами при получении запроса с браузера





















